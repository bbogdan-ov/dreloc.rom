// ==============================
// Devices
// ==============================

untyped enum byte System {
	r     { 0x08 }
	g     { 0x0a }
	b     { 0x0c }
	debug { 0x0e }
}

untyped enum byte Screen {
	vector { 0x20 }
	width  { 0x22 }
	height { 0x24 }
	auto   { 0x26 }
	x      { 0x28 }
	y      { 0x2a }
	addr   { 0x2c }
	pixel  { 0x2e }
	sprite { 0x2f }
}

untyped enum byte Mouse {
	vector { 0x90 }
	x      { 0x92 }
	y      { 0x94 }
	state  { 0x96 }
}

untyped enum byte DateTime {
	year   { 0xc0 }
	month  { 0xc2 }
	day    { 0xc3 }
	hour   { 0xc4 }
	minute { 0xc5 }
	second { 0xc6 }
	dotw   { 0xc7 }
	doty   { 0xc8 }
	isdst  { 0xca }
}

// ==============================
// Constants
// ==============================

enum byte Dir { down left up right }

const short SCREEN_WIDTH  { 512* }
const short SCREEN_HEIGHT { 512* }

const short GRID_SIZE { 16* }

// ==============================
// Variables
// ==============================

struct Cursor {
	short x
	short y
	byte  grab
}

var Cursor cursor

// Number of frames elapsed from the start
var short elapsed

// ==============================
// Vectors
// ==============================

fun on-reset ( -> ) {
	0xf0af* System.r output
	0xf0af* System.g output
	0xf0af* System.b output

	prng-init
	dreloc-init

	SCREEN_WIDTH  Screen.width output
	SCREEN_HEIGHT Screen.height output

	&on-screen Screen.vector output
	&on-mouse  Mouse.vector output

	flowers-populate
	flakes-populate
}

fun on-screen ( -> ) {
	// Clear the whole screen
	// TODO: may be i should come up with a better way to redraw game objects
	0* Screen.x output
	0* Screen.y output
	0b10000000 Screen.pixel output

	dreloc-update

	// Calculate index used for slicing the array of flowers
	{ dreloc.y DRELOC_HEIGHT add FLOWER_HEIGHT sub } FLOWERS_GAP_Y div -> (idx)

	(idx) dup flowers-draw-below
	campfire-draw
	dreloc-draw
	(idx) flowers-draw-above
	flakes-draw

	// Draw mouse cursor
	cursor.grab if { &sprite-cursor-grab } else { &sprite-cursor } Screen.addr output
	0b00010110 Screen.auto output
	cursor.x   Screen.x output
	cursor.y   Screen.y output
	0b10000101 Screen.sprite output-k output

	elapsed inc -> elapsed
}

fun on-mouse ( -> ) {
	// Draw new cursor
	Mouse.x input2 -> cursor.x
	Mouse.y input2 -> cursor.y

	// Check whether the cursor is hovering over a non-picked up flower
	cursor.y FLOWERS_GAP_Y sub FLOWERS_GAP_Y div -> (flower-idx) sth
	sth-rk (flower-idx) flowers[].picked not if {
		sth-rk (flower-idx) flowers[].x sth
		sth-rk cursor.x lth
		sth-r  cursor.x FLOWER_WIDTH sub gth
		and -> (picking)
	} else {
		0 -> (picking)
	}

	(picking) -> cursor.grab

	Mouse.state input if {
		cursor.grab -> dreloc.is-picking
		cursor.grab if { sth-rk (flower-idx) -> dreloc.pick-idx }

		dreloc-move-to-cursor
	}

	pop-r
}

// ==============================
// Dreloc
// ==============================

const short DRELOC_WIDTH      { 72* }
const short DRELOC_HEIGHT     { 96* }
const short DRELOC_WALK_SPEED { 2* }
const byte  DRELOC_COLOR      { 5 }

const byte DRELOC_REST_DELAY { 120 }

const byte  DRELOC_WALK_FRAMES { 4 }
const byte  DRELOC_REST_FRAMES { 3 }
const byte  DRELOC_PICK_FRAMES { 4 }
// Delay between animation frames in game frames
const byte  DRELOC_FRAMES_DELAY { 8 }
// Data offset between frames in bytes
const short DRELOC_FRAME_STRIDE { 1728* }

// Dreloc's state
enum byte State {
	idle
	walk
	rest
	stand-up
	pick
}

struct Dreloc {
	short x
	short y
	short target-x
	short target-y

	State state
	byte  is-picking
	short pick-idx

	byte  walk-frame
	Dir   walk-dir
	byte  rest-timer
	byte  rest-frame
	byte  pick-frame
}

var Dreloc dreloc

fun dreloc-init ( -- ) {
	CAMPFIRE_X DRELOC_WIDTH sub -> dreloc.x
	CAMPFIRE_Y DRELOC_HEIGHT 2* div sub -> dreloc.y
	Dir.right -> dreloc.walk-dir
	State.rest dreloc-set-state
	DRELOC_REST_FRAMES DRELOC_FRAMES_DELAY mul -> dreloc.rest-frame
}

fun dreloc-update ( -- ) {
	dreloc.state State.walk eq if {
		dreloc-update-walk-anim
		dreloc-update-movement
	}
	elif dreloc.state State.idle eq {
		// Stop walking animation but set it to a "half" of a frame, so when
		// animation plays again it starts almost immediately
		DRELOC_FRAMES_DELAY 2 div -> dreloc.walk-frame

		dreloc-update-rest-timer
	}
	elif dreloc.state State.rest     eq { dreloc-update-sit-down-anim }
	elif dreloc.state State.stand-up eq { dreloc-update-stand-up-anim }
	elif dreloc.state State.pick     eq { dreloc-update-pick-up-anim }
}

fun dreloc-update-movement ( -- ) {
	dreloc.x dreloc.target-x neq if {
		// Move horizontally
		dreloc.x dreloc.target-x lth
		if { Dir.right } else { Dir.left } dreloc-move
	} elif dreloc.y dreloc.target-y neq {
		// Move vertically
		dreloc.y dreloc.target-y lth
		if { Dir.down } else { Dir.up } dreloc-move
	} else {
		dreloc.is-picking if { State.pick } else { State.idle } dreloc-set-state
	}
}

fun dreloc-update-walk-anim ( -- ) {
	{ dreloc.walk-frame inc } { DRELOC_WALK_FRAMES DRELOC_FRAMES_DELAY mul } mod
	-> dreloc.walk-frame
}
fun dreloc-update-sit-down-anim ( -- ) {
	dreloc.rest-frame { DRELOC_REST_FRAMES DRELOC_FRAMES_DELAY mul } lth
	if { dreloc.rest-frame inc -> dreloc.rest-frame }
}
fun dreloc-update-stand-up-anim ( -- ) {
	dreloc.rest-frame 0 gth
	if   { dreloc.rest-frame 1 sub -> dreloc.rest-frame }
	else { State.walk dreloc-set-state }
}
fun dreloc-update-pick-up-anim ( -- ) {
	dreloc.pick-frame { DRELOC_PICK_FRAMES DRELOC_FRAMES_DELAY mul } lth
	if {
		dreloc.pick-frame
		dup { 2 DRELOC_FRAMES_DELAY mul } eq if { 1 dreloc.pick-idx -> flowers[].picked }
		1 add -> dreloc.pick-frame
	} else {
		0 -> dreloc.pick-frame
		State.idle dreloc-set-state
	}
}

fun dreloc-update-rest-timer ( -- ) {
	dreloc.rest-timer 0 gth
	if   { dreloc.rest-timer 1 sub -> dreloc.rest-timer }
	else { State.rest dreloc-set-state }
}

fun dreloc-draw ( -- ) {
	// Choose frame based on in which direction Dreloc is looking
	/**/ dreloc.walk-dir Dir.down  eq if { 0* }
	elif dreloc.walk-dir Dir.left  eq    { DRELOC_FRAME_STRIDE 3* mul }
	elif dreloc.walk-dir Dir.up    eq    { DRELOC_FRAME_STRIDE 6* mul }
	elif dreloc.walk-dir Dir.right eq    { DRELOC_FRAME_STRIDE 9* mul }
	else { 0* } -> (frame)

	dreloc.state State.walk eq if {
		{ dreloc.walk-frame DRELOC_FRAMES_DELAY } div sth
		/**/ sth-kr 1 eq if { (frame) DRELOC_FRAME_STRIDE add -> (frame) }
		elif sth-kr 2 eq    { (frame) }
		elif sth-kr 3 eq    { (frame) DRELOC_FRAME_STRIDE 2* mul add -> (frame) }
		pop-r
	}

	{ dreloc.rest-frame DRELOC_FRAMES_DELAY } div sth
	/**/ sth-kr 1 eq if { (frame) DRELOC_FRAME_STRIDE 12* mul add -> (frame) }
	elif sth-kr 2 eq    { (frame) DRELOC_FRAME_STRIDE 13* mul add -> (frame) }
	elif sth-kr 3 eq    { (frame) DRELOC_FRAME_STRIDE 14* mul add -> (frame) }
	pop-r

	{ dreloc.pick-frame DRELOC_FRAMES_DELAY } div sth
	/**/ sth-kr 1 eq if { (frame) DRELOC_FRAME_STRIDE 12* mul add -> (frame) }
	elif sth-kr 2 eq    { (frame) DRELOC_FRAME_STRIDE 13* mul add -> (frame) }
	elif sth-kr 3 eq    { (frame) DRELOC_FRAME_STRIDE 12* mul add -> (frame) }
	pop-r

	{ (frame) &sprite-dreloc add } Screen.addr output

	dreloc.x Screen.x output
	dreloc.y Screen.y output

	0b10000110 Screen.auto output
	0b10000000 DRELOC_COLOR or Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output
}

fun dreloc-move-to-cursor ( -- ) {
	// Check whether the cursor is inside the campfire
	CAMPFIRE_X      cursor.x lth
	CAMPFIRE_RIGHT  cursor.x gth and
	CAMPFIRE_Y      cursor.y lth and
	CAMPFIRE_BOTTOM cursor.y gth and
	if { return }

	{
		{ cursor.x snap } { DRELOC_WIDTH 2* div } { SCREEN_WIDTH DRELOC_WIDTH 2* div sub } clamp
		{ DRELOC_WIDTH 2* div } sub
		{ GRID_SIZE 2* div } add
	} -> dreloc.target-x

	{
		cursor.y -> (y)
		
		// Set target Y a bit lower when picking up a flower
		dreloc.is-picking if { (y) FLOWER_HEIGHT 2* div add -> (y) }

		{ (y) snap } DRELOC_HEIGHT SCREEN_HEIGHT clamp
		DRELOC_HEIGHT sub
		GRID_SIZE add
	} -> dreloc.target-y

	dreloc.state State.rest eq if {
		State.stand-up dreloc-set-state
	} elif dreloc.state State.idle eq {
		State.walk dreloc-set-state
	}
}

fun dreloc-move ( Dir:dir -- ) {
	dup (dir) Dir.right eq if {
		// Move right
		dreloc.x DRELOC_WALK_SPEED add -> dreloc.x
	} elif dup (dir) Dir.left eq {
		// Move left
		dreloc.x DRELOC_WALK_SPEED sub -> dreloc.x
	} elif dup (dir) Dir.down eq {
		// Move down
		dreloc.y DRELOC_WALK_SPEED add -> dreloc.y
	} elif dup (dir) Dir.up eq {
		// Move up
		dreloc.y DRELOC_WALK_SPEED sub -> dreloc.y
	}

	(dir) -> dreloc.walk-dir
}

fun dreloc-set-state ( State -- ) {
	-> dreloc.state
	DRELOC_REST_DELAY -> dreloc.rest-timer
}

// ==============================
// Campfire
// ==============================

const short CAMPFIRE_WIDTH  { 72* }
const short CAMPFIRE_HEIGHT { 48* }
const short CAMPFIRE_X      { SCREEN_WIDTH 2*  div CAMPFIRE_WIDTH 2*  div sub }
const short CAMPFIRE_Y      { SCREEN_HEIGHT 2* div CAMPFIRE_HEIGHT 2* div sub }
const short CAMPFIRE_RIGHT  { CAMPFIRE_X CAMPFIRE_WIDTH add }
const short CAMPFIRE_BOTTOM { CAMPFIRE_Y CAMPFIRE_HEIGHT add }

fun campfire-draw ( -- ) {
	CAMPFIRE_X Screen.x output
	CAMPFIRE_Y Screen.y output

	0b10000110       Screen.auto output
	&sprite-campfire Screen.addr output
	0b10000000 5 or  Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output-k
		output
}

// ==============================
// Flowers
// ==============================

const short FLOWER_WIDTH  { 16* }
const short FLOWER_HEIGHT { 38* }
const byte  FLOWER_BITS   { 0b10000101 }
const short FLOWERS_COUNT { 94* }
const short FLOWERS_GAP_Y { 5* }

struct Flower {
	short x
	byte  picked
}

rom var [94]Flower flowers

fun flowers-populate ( -- ) {
	0* -> (idx) while dup FLOWERS_COUNT lth {
		(idx) sth

		// Randomize X so that flowers do not overlap with the campfire
		0* -> (x) sth
		loop @exit {
			pop-r
			prng { SCREEN_WIDTH FLOWER_WIDTH sub } mod2 -> (x) sth

			sth-rk (x) CAMPFIRE_X     GRID_SIZE sub FLOWER_WIDTH sub lth
			sth-rk (x) CAMPFIRE_RIGHT GRID_SIZE add                  gth or
			swap-r
			sth-rk (idx) FLOWERS_GAP_Y mul sth
			sth-rk CAMPFIRE_Y FLOWER_HEIGHT sub GRID_SIZE sub lth or
			sth-r  CAMPFIRE_Y FLOWER_HEIGHT add GRID_SIZE add gth or
			swap-r
			if { jump @exit }
		}

		sth-r (x) sth-rk (idx) -> flowers[].x
		sth-r (idx) inc
	} pop
}

fun flowers-draw-below ( short:end-idx -- ) {
	sth
	0* while dup sth-rk lth {
		dup flower-draw
		inc
	} pop
	pop-r
}

fun flowers-draw-above ( short:start-idx -- ) {
	while dup FLOWERS_COUNT lth {
		dup flower-draw
		inc
	} pop
}

fun flower-draw ( short:idx -- ) {
	dup (idx) flowers[].picked if { pop return }

	(idx) dup 5* mod2 sth
	/**/ sth-rk 1* eq if { &sprite-flower-2 }
	elif sth-rk 2* eq    { &sprite-flower-3 }
	elif sth-rk 3* eq    { &sprite-flower-4 }
	elif sth-rk 4* eq    { &sprite-flower-5 }
	else                 { &sprite-flower-1 }
	pop-r

	Screen.addr output
	0b00010110 Screen.auto output

	{ dup (idx) FLOWERS_GAP_Y mul } Screen.y output
	{ dup (idx) flowers[].x } -> (x)

	// Calculate sine offset
	{ dup (x) 80* div } { rot (idx) 10* div } add
	{ elapsed 12* div } sub -> (sine-offset)

	// Draw rows of the flower sprite
	(x sine-offset)
	over over 60*  flower-draw-row
	over over 90*  flower-draw-row
	over over 120* flower-draw-row
	over over 150* flower-draw-row
	(sine-offset) pop

	// Draw the last (bottom) row of the sprite
	(x)         Screen.x output
	FLOWER_BITS Screen.sprite output
}

// Animate X position of a single flower sprite row using sine lookup table
fun flower-draw-row ( short:x short:sine-offset short:divide -- ) {
	swap

	// Calculate X shifting/tilt for the row
	(sine-offset) sin to-short swap (divide) div -> (tilt)

	(x tilt) add Screen.x output
	FLOWER_BITS  Screen.sprite output
}

// ==============================
// Snow flakes
// ==============================

const byte  FLAKE_BITS   { 0b00001111 }
const short FLAKES_COUNT { 60* }

// Flake
struct Flake {
	// X and Y are fixed point numbers with precision of 1
	short x
	short y
	short speed
}

rom var [60]Flake flakes

fun flakes-populate ( -- ) {
	0* while dup FLAKES_COUNT lth {
		sth
		{ prng SCREEN_WIDTH mod2 }  10* mul sth-rk -> flakes[].x
		{ prng SCREEN_HEIGHT mod2 } 10* mul sth-rk -> flakes[].y
		{ prng 10* mod2 }           10* add sth-rk -> flakes[].speed
		sth-r inc
	} pop
}

fun flakes-draw ( -- ) {
	0 Screen.auto output
	&sprite-flake Screen.addr output

	0* -> (idx) while dup FLAKES_COUNT lth {
		(idx) sth

		sth-rk flakes[].x -> (x)
		sth-rk flakes[].y -> (y)

		// Move flake vertically
		dup (y) { sth-rk flakes[].speed } add sth-rk -> flakes[].y

		// Move flake horizontally
		{ (y) 100* div } sth-rk (idx) add sin to-short 5* div -> (delta)
		(x delta) add sth-rk -> flakes[].x

		// Draw the flake
		// Devide X and Y by 10 because these are fixed point number with precision of 1
		{ sth-rk flakes[].x 10* div } -> (x) dup Screen.x output
		{ sth-rk flakes[].y 10* div } -> (y) dup Screen.y output
		FLAKE_BITS Screen.sprite output

		// Wrap flake from one screen edge to another
		(y) SCREEN_HEIGHT gth if { 0* sth-rk -> flakes[].y }
		(x) SCREEN_WIDTH  gth if { 0* sth-rk -> flakes[].x }

		sth-r (idx) inc
	} pop
}

// ==============================
// Utils
// ==============================

fun clamp ( short:value short:min short:max -- short ) {
	sth sth

	sth-r lth-k (value min _) if { pop-r nip return } else { pop }
	sth-r gth-k (value max _) if {       nip return } else { pop }
	(value)
}

// Snap value to the grid
fun snap ( short -- short ) {
	GRID_SIZE div GRID_SIZE mul
}

fun not ( byte -- byte ) { 0 eq }
fun mod ( byte:num byte:divisor -- byte:remainder ) { div-k mul sub }
fun mod2 ( short:num short:divisor -- short:remainder ) { div-k mul sub }

fun to-short ( byte -- short ) { 0 swap as (short) }

// Pseudo-random functions ported from UXNTAL
// https://wiki.xxiivv.com/site/uxntal_software.html

var short prng-x
var short prng-y

fun prng-init ( -- ) {
	0 DateTime.second input as (short)
		0 DateTime.minute input as (short) 0x60 shift xor
		0 DateTime.hour   input as (short) 0xc0 shift xor -> prng-x
	0 DateTime.hour input as (short) 0x04 shift
		0 DateTime.day   input as (short) 0x10 shift xor
		0 DateTime.month input as (short) 0x60 shift xor
		DateTime.year input2 0xa0 shift xor -> prng-y
}
fun prng ( -- short ) {
	prng-x
		dup 0x50 shift xor
		dup 0x03 shift xor
	prng-y dup -> prng-x
		dup 0x01 shift xor xor
		&prng-y store-k pop
}


// Number of values inside `sine-lookup` table
const short SINE_LOOKUP_N { 30* }
data sine-lookup { include "assets/sine.bin" }

fun sin ( short -- byte ) {
	SINE_LOOKUP_N mod2 sine-lookup[]
}

// ==============================
// Assets
// ==============================

data sprite-flake {
	0b01010100
	0b11010110
	0b00111000
	0b11111110
	0b00111000
	0b11010110
	0b01010100
	0b00000000
}

data sprite-dreloc      { include "assets/dreloc.chr" }
data sprite-campfire    { include "assets/campfire.chr" }
data sprite-flower-1    { include "assets/flower-1.chr" }
data sprite-flower-2    { include "assets/flower-2.chr" }
data sprite-flower-3    { include "assets/flower-3.chr" }
data sprite-flower-4    { include "assets/flower-4.chr" }
data sprite-flower-5    { include "assets/flower-5.chr" }
data sprite-cursor      { include "assets/cursor.chr" }
data sprite-cursor-grab { include "assets/cursor-grab.chr" }
