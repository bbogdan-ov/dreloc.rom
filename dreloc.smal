// ==============================
// Devices
// ==============================

untyped enum byte System {
	r     { 0x08 }
	g     { 0x0a }
	b     { 0x0c }
	debug { 0x0e }
}

untyped enum byte Screen {
	vector { 0x20 }
	width  { 0x22 }
	height { 0x24 }
	auto   { 0x26 }
	x      { 0x28 }
	y      { 0x2a }
	addr   { 0x2c }
	pixel  { 0x2e }
	sprite { 0x2f }
}

untyped enum byte Mouse {
	vector { 0x90 }
	x      { 0x92 }
	y      { 0x94 }
	state  { 0x96 }
}

untyped enum byte DateTime {
	year   { 0xc0 }
	month  { 0xc2 }
	day    { 0xc3 }
	hour   { 0xc4 }
	minute { 0xc5 }
	second { 0xc6 }
	dotw   { 0xc7 }
	doty   { 0xc8 }
	isdst  { 0xca }
}

// ==============================
// Constants
// ==============================

enum byte Dir { down left up right }

enum byte Scene { intro field }

const short SCREEN_WIDTH  { 512* }
const short SCREEN_HEIGHT { 512* }

const short GRID_SIZE { 16* }

// Delay between anim frames in game frames
const byte FRAME_DELAY { 8 }

// ==============================
// Variables
// ==============================

struct Cursor {
	short x
	short y
	byte  grab
}

var Cursor cursor

// Number of frames elapsed from the start
var short elapsed
// Current scene
var Scene scene

// ==============================
// Vectors
// ==============================

fun on-reset ( -> ) {
	SCREEN_WIDTH  Screen.width output
	SCREEN_HEIGHT Screen.height output

	&on-screen Screen.vector output
	&on-mouse  Mouse.vector output

	prng-init
	dreloc-init
	campfire-init
	intro-draw-background

	flowers-populate
	flakes-populate
}

fun on-screen ( -> ) {
	scene Scene.intro eq if {
		intro-draw-foreground
	} else {
		dreloc-update
		campfire-update

		field-draw-foreground
	}

	elapsed inc -> elapsed
}

fun on-mouse ( -> ) {
	Mouse.x input2 -> cursor.x
	Mouse.y input2 -> cursor.y

	scene Scene.field neq if { return }

	// Check whether the cursor is hovering over a non-picked up flower
	cursor.y FLOWERS_GAP_Y sub FLOWERS_GAP_Y div -> (flower-idx) sth
	sth-rk (flower-idx) flowers[].picked not if {
		sth-rk (flower-idx) flowers[].x sth
		sth-rk cursor.x lth
		sth-r  cursor.x FLOWER_WIDTH sub gth
		and -> (picking)
	} else {
		0 -> (picking)
	}

	(picking) -> cursor.grab

	Mouse.state input if {
		cursor.grab -> dreloc.is-picking
		cursor.grab if { sth-rk (flower-idx) -> dreloc.pick-idx }

		dreloc-move-to-cursor
	}

	pop-r
}

fun goto-field ( -- ) {
	Scene.field -> scene
	field-draw-background
}

// ==============================
// Intro
// ==============================

const short INTRO_DRELOC_X    { { SCREEN_WIDTH 2* div } { DRELOC_WIDTH 2* div } sub }
const short INTRO_DRELOC_Y    { { SCREEN_HEIGHT 2* div } { DRELOC_HEIGHT 2* div } sub }
const *byte INTRO_DRELOC_ADDR { { 2* dreloc-rest-frame-offset } &sprite-dreloc add }

const short INTRO_BLOOM_X { { SCREEN_WIDTH 2* div } { BLOOM_WIDTH 2* div } sub }
const short INTRO_BLOOM_Y { { SCREEN_HEIGHT 2* div } { BLOOM_HEIGHT 2* div } sub 40* add }

const short INTRO_NIMB_X { SCREEN_WIDTH 2* div }
const short INTRO_NIMB_Y { { SCREEN_HEIGHT 2* div } 48* sub }
const short INTRO_NIMB_TIME { 200* } // Game frame at which nimb animation should stop

const short INTRO_FADE_IN_TIME        { 100* }
const short INTRO_FADE_OUT_START_TIME { 300* }
const short INTRO_FADE_OUT_TIME       { 100* }

fun intro-draw-foreground ( -- ) {
	// Clear layer
	0* Screen.x output
	0* Screen.y output
	0b11000000 Screen.pixel output

	intro-update-palette

	// Draw nimb
	0b01000110 Screen.auto output

	// Animate nimb Y position using lerp and ease-out-quant
	// There is a lot of magic numbers, i know
	{
		elapsed INTRO_NIMB_TIME min2 -> (alpha)
		0* -> (from)
		INTRO_NIMB_Y -> (to)

		over (to from) sub -> (diff)
		rot (from diff alpha)
		{ // ease-out-quant
			(alpha) {
				INTRO_NIMB_TIME swap (_ alpha) sub
				dup mul INTRO_NIMB_TIME div // pow(x, 2)
				dup mul INTRO_NIMB_TIME div // pow(x, 2)
			} -> (alpha)
			(alpha) INTRO_NIMB_TIME swap (_ alpha) sub -> (alpha)
		}
		(diff alpha) mul INTRO_NIMB_TIME div -> (delta)
		(from delta) add
	} -> (nimb-y)

	// Draw right part
	&sprite-nimb Screen.addr output
	INTRO_NIMB_X Screen.x output
	(nimb-y) dup Screen.y output
	0b01001111   Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output

	// Draw left part
	&sprite-nimb        Screen.addr output
	INTRO_NIMB_X 8* sub Screen.x output
	(nimb-y)            Screen.y output
	0b01011111          Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output
}

fun intro-draw-background ( -- ) {
	// Clear layer
	0* Screen.x output
	0* Screen.y output
	0b10000000 Screen.pixel output

	// Draw bloom
	&sprite-bloom Screen.addr output
	0b10010110    Screen.auto output
	INTRO_BLOOM_X Screen.x output
	INTRO_BLOOM_Y Screen.y output
	0b00000011    Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output

	// Draw dreloc
	INTRO_DRELOC_ADDR Screen.addr output
	INTRO_DRELOC_X    Screen.x output
	INTRO_DRELOC_Y    Screen.y output
	0b10000110        Screen.auto output
	0b10000000 DRELOC_COLOR or Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output
}

fun intro-update-palette ( -- ) {
	// Animate palette fade-in and fade-out
	elapsed INTRO_FADE_OUT_START_TIME lth if {
		elapsed LERP_COLOR_RESOLUTION mul INTRO_FADE_IN_TIME div -> (t)
	} else {
		elapsed INTRO_FADE_OUT_START_TIME sub -> (t)
		(t) dup INTRO_FADE_OUT_TIME lth if {
			(t) LERP_COLOR_RESOLUTION mul INTRO_FADE_OUT_TIME div -> (t)
			LERP_COLOR_RESOLUTION swap (_ t) sub -> (t)
		} else {
			goto-field
			(t) pop return
		}
	}

	(t) sth {
		sth-rk 0x0* 0xf* lerp-color
		sth-rk 0x0* 0xa* lerp-color 0x40 shift or
		sth-rk 0x0* 0x0* lerp-color 0x80 shift or
		sth-rk 0x0* 0x5* lerp-color 0xc0 shift or -> (r)
		(r) System.r output

		sth-rk 0x0* 0xf* lerp-color
		sth-rk 0x0* 0xa* lerp-color 0x40 shift or
		sth-rk 0x0* 0x0* lerp-color 0x80 shift or
		sth-rk 0x0* 0xa* lerp-color 0xc0 shift or -> (c)
		(c) dup System.g output
		(c)     System.b output
	} pop-r
}

// ==============================
// Field
// ==============================

const short FIELD_FADE_IN_START_TIME { INTRO_FADE_OUT_START_TIME INTRO_FADE_OUT_TIME add }
const short FIELD_FADE_IN_TIME       { 100* }

fun field-draw-foreground ( -- ) {
	// Clear layer
	0* Screen.x output
	0* Screen.y output
	0b11000000 Screen.pixel output

	// Animate fade-in
	elapsed { FIELD_FADE_IN_START_TIME FIELD_FADE_IN_TIME add } gth not if {
		elapsed FIELD_FADE_IN_START_TIME sub LERP_COLOR_RESOLUTION mul FIELD_FADE_IN_TIME div sth
		sth-rk 0x0* 0xf* lerp-color
		sth-rk 0x0* 0xa* lerp-color 0x40 shift or
		sth-rk 0x0* 0x0* lerp-color 0x80 shift or
		sth-r  0x0* 0xf* lerp-color 0xc0 shift or -> (c)
		(c) dup System.r output
		(c) dup System.g output
		(c)     System.b output
	}

	// Calculate index used for slicing the array of flowers
	{ dreloc.y DRELOC_HEIGHT add FLOWER_HEIGHT sub } FLOWERS_GAP_Y div -> (idx)

	(idx) dup flowers-draw-below
	campfire-fire-draw-below
	dreloc-draw
	campfire-fire-draw-above
	(idx) flowers-draw-above
	flakes-draw

	// Draw mouse cursor
	&sprite-cursor cursor.grab if { 64* add } Screen.addr output
	0b00010110 Screen.auto output
	cursor.x   Screen.x output
	cursor.y   Screen.y output
	0b11000101 Screen.sprite output-k output
}

fun field-draw-background ( -- ) {
	// Clear layer
	0* Screen.x output
	0* Screen.y output
	0b10000000 Screen.pixel output

	// Draw patches of grass
	0b00010110 Screen.auto output
	0* -> (idx) while dup 50* lth {
		(idx) dup GRASS_FRAMES mod2 GRASS_FRAME_STRIDE mul &sprite-grass add -> (addr)
		(addr) Screen.addr output

		prng { SCREEN_WIDTH GRASS_WIDTH sub }   mod2 Screen.x output
		prng { SCREEN_HEIGHT GRASS_HEIGHT sub } mod2 Screen.y output
		0b00000010 Screen.sprite output-k output
		(idx) inc
	} pop

	campfire-draw
}

// ==============================
// Dreloc
// ==============================

const short DRELOC_WIDTH      { 72* }
const short DRELOC_HEIGHT     { 96* }
const short DRELOC_WALK_SPEED { 2* }
const byte  DRELOC_COLOR      { 5 }

const byte DRELOC_REST_DELAY { 120 }

const byte  DRELOC_WALK_FRAMES { 4 }
const byte  DRELOC_REST_FRAMES { 3 }
const byte  DRELOC_PICK_FRAMES { 4 }
// Delay between animation frames in game frames
// Data offset between frames in bytes
const short DRELOC_FRAME_STRIDE { 1728* }

// Dreloc's state
enum byte State {
	idle
	walk
	rest
	stand-up
	pick
}

struct Dreloc {
	short x
	short y
	short prev-x
	short prev-y
	short target-x
	short target-y

	State state
	byte  is-picking
	short pick-idx

	byte  walk-frame
	Dir   walk-dir
	byte  rest-timer
	byte  rest-frame
	byte  pick-frame
}

var Dreloc dreloc

fun dreloc-init ( -- ) {
	CAMPFIRE_X DRELOC_WIDTH sub -> dreloc.x
	CAMPFIRE_Y DRELOC_HEIGHT 2* div sub -> dreloc.y
	Dir.right -> dreloc.walk-dir
	State.rest dreloc-set-state
	DRELOC_REST_FRAMES FRAME_DELAY mul -> dreloc.rest-frame
}

fun dreloc-update ( -- ) {
	dreloc.state State.walk eq if {
		dreloc-update-walk-anim
		dreloc-update-movement
	}
	elif dreloc.state State.idle eq {
		// Stop walking animation but set it to a "half" of a frame, so when
		// animation plays again it starts almost immediately
		FRAME_DELAY 2 div -> dreloc.walk-frame

		dreloc-update-rest-timer
	}
	elif dreloc.state State.rest     eq { dreloc-update-sit-down-anim }
	elif dreloc.state State.stand-up eq { dreloc-update-stand-up-anim }
	elif dreloc.state State.pick     eq { dreloc-update-pick-up-anim }
}

fun dreloc-update-movement ( -- ) {
	dreloc.x dreloc.target-x neq if {
		// Move horizontally
		dreloc.x dreloc.target-x lth
		if { Dir.right } else { Dir.left } dreloc-move
	} elif dreloc.y dreloc.target-y neq {
		// Move vertically
		dreloc.y dreloc.target-y lth
		if { Dir.down } else { Dir.up } dreloc-move
	} else {
		dreloc.is-picking if { State.pick } else { State.idle } dreloc-set-state
	}
	
	// Check whether Dreloc overlaps with the campfire
	CAMPFIRE_X      { dreloc.x DRELOC_WIDTH 2* div add }         lth
	CAMPFIRE_RIGHT  { dreloc.x DRELOC_WIDTH 2* div add }         gth and
	CAMPFIRE_Y      { dreloc.y DRELOC_HEIGHT add }               lth and
	CAMPFIRE_BOTTOM { dreloc.y DRELOC_HEIGHT add GRID_SIZE sub } gth and
	if {
		dreloc.prev-x -> dreloc.x
		dreloc.prev-y -> dreloc.y
		State.idle dreloc-set-state
	}
}

fun dreloc-update-walk-anim ( -- ) {
	{ dreloc.walk-frame inc } { DRELOC_WALK_FRAMES FRAME_DELAY mul } mod
	-> dreloc.walk-frame
}
fun dreloc-update-sit-down-anim ( -- ) {
	dreloc.rest-frame { DRELOC_REST_FRAMES FRAME_DELAY mul } lth
	if { dreloc.rest-frame inc -> dreloc.rest-frame }
}
fun dreloc-update-stand-up-anim ( -- ) {
	dreloc.rest-frame 0 gth
	if   { dreloc.rest-frame 1 sub -> dreloc.rest-frame }
	else { State.walk dreloc-set-state }
}
fun dreloc-update-pick-up-anim ( -- ) {
	dreloc.pick-frame { DRELOC_PICK_FRAMES FRAME_DELAY mul } lth
	if {
		dreloc.pick-frame -> (frame)
		dup (frame) { 2 FRAME_DELAY mul } eq if {
			dreloc-pick-up-flower
		}
		(frame) inc -> dreloc.pick-frame
	} else {
		0 -> dreloc.pick-frame
		State.idle dreloc-set-state
	}
}

fun dreloc-update-rest-timer ( -- ) {
	dreloc.rest-timer 0 gth
	if   { dreloc.rest-timer 1 sub -> dreloc.rest-timer }
	else { State.rest dreloc-set-state }
}

const short DRELOC_DOWN_FRAME_OFFSET { 0* }

fun dreloc-rest-frame-offset ( short:idx -- short ) {
	12* add DRELOC_FRAME_STRIDE mul
}

fun dreloc-draw ( -- ) {
	// Choose frame based on in which direction Dreloc is looking
	/**/ dreloc.walk-dir Dir.down  eq if { 0* }
	elif dreloc.walk-dir Dir.left  eq    { DRELOC_FRAME_STRIDE 3* mul }
	elif dreloc.walk-dir Dir.up    eq    { DRELOC_FRAME_STRIDE 6* mul }
	elif dreloc.walk-dir Dir.right eq    { DRELOC_FRAME_STRIDE 9* mul }
	else { 0* } -> (frame)

	dreloc.state State.walk eq if {
		{ dreloc.walk-frame FRAME_DELAY } div sth
		/**/ sth-kr 1 eq if { (frame) DRELOC_FRAME_STRIDE add -> (frame) }
		elif sth-kr 2 eq    { (frame) }
		elif sth-kr 3 eq    { (frame) DRELOC_FRAME_STRIDE 2* mul add -> (frame) }
		pop-r
	}

	{ dreloc.rest-frame FRAME_DELAY } div sth
	/**/ sth-kr 0 eq if { (frame) }
	elif sth-kr 1 eq    { (frame) 0* dreloc-rest-frame-offset add -> (frame) }
	elif sth-kr 2 eq    { (frame) 1* dreloc-rest-frame-offset add -> (frame) }
	elif sth-kr 3 eq    { (frame) 2* dreloc-rest-frame-offset add -> (frame) }
	pop-r

	{ dreloc.pick-frame FRAME_DELAY } div sth
	/**/ sth-kr 0 eq if { (frame) }
	elif sth-kr 1 eq    { (frame) 0* dreloc-rest-frame-offset add -> (frame) }
	elif sth-kr 2 eq    { (frame) 1* dreloc-rest-frame-offset add -> (frame) }
	elif sth-kr 3 eq    { (frame) 0* dreloc-rest-frame-offset add -> (frame) }
	pop-r

	{ (frame) &sprite-dreloc add } Screen.addr output

	dreloc.x Screen.x output
	dreloc.y Screen.y output

	0b10000110 Screen.auto output
	0b11000000 DRELOC_COLOR or Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output
}

fun dreloc-pick-up-flower ( -- ) {
	1 dreloc.pick-idx -> flowers[].picked
	campfire-throw-flower
}

fun dreloc-move-to-cursor ( -- ) {
	{
		{ cursor.x snap } { DRELOC_WIDTH 2* div } { SCREEN_WIDTH DRELOC_WIDTH 2* div sub } clamp
		{ DRELOC_WIDTH 2* div } sub
		{ GRID_SIZE 2* div } add
	} -> dreloc.target-x

	{
		cursor.y -> (y)
		
		// Set target Y a bit lower when picking up a flower
		dreloc.is-picking if { (y) FLOWER_HEIGHT 2* div add -> (y) }

		{ (y) snap } DRELOC_HEIGHT SCREEN_HEIGHT clamp
		DRELOC_HEIGHT sub
		GRID_SIZE add
	} -> dreloc.target-y

	dreloc.state State.rest eq if {
		State.stand-up dreloc-set-state
	} elif dreloc.state State.idle eq {
		State.walk dreloc-set-state
	}
}

fun dreloc-move ( Dir:dir -- ) {
	dreloc.x -> dreloc.prev-x
	dreloc.y -> dreloc.prev-y

	dup (dir) Dir.right eq if {
		// Move right
		dreloc.x DRELOC_WALK_SPEED add -> dreloc.x
	} elif dup (dir) Dir.left eq {
		// Move left
		dreloc.x DRELOC_WALK_SPEED sub -> dreloc.x
	} elif dup (dir) Dir.down eq {
		// Move down
		dreloc.y DRELOC_WALK_SPEED add -> dreloc.y
	} elif dup (dir) Dir.up eq {
		// Move up
		dreloc.y DRELOC_WALK_SPEED sub -> dreloc.y
	}

	(dir) -> dreloc.walk-dir
}

fun dreloc-set-state ( State -- ) {
	-> dreloc.state
	DRELOC_REST_DELAY -> dreloc.rest-timer
}

// ==============================
// Campfire
// ==============================

const short CAMPFIRE_WIDTH       { 72* }
const short CAMPFIRE_HEIGHT      { 48* }
const short CAMPFIRE_X           { SCREEN_WIDTH 2*  div CAMPFIRE_WIDTH 2*  div sub }
const short CAMPFIRE_Y           { SCREEN_HEIGHT 2* div CAMPFIRE_HEIGHT 2* div sub }
const short CAMPFIRE_RIGHT       { CAMPFIRE_X CAMPFIRE_WIDTH add }
const short CAMPFIRE_BOTTOM      { CAMPFIRE_Y CAMPFIRE_HEIGHT add }
const byte  CAMPFIRE_MAX_FUEL    { 60 }
const short CAMPFIRE_CRITICAL_FUEL { 40* }
// How much fuel gives a single flower
const byte  CAMPFIRE_FLOWER_FUEL { 6 }
const byte  CAMPFIRE_TIMER_DELAY { 30 }

const short FIRE_WIDTH        { 40* }
const short FIRE_HEIGHT       { 64* }
const short FIRE_X            { CAMPFIRE_X { CAMPFIRE_WIDTH 2* div } add { FIRE_WIDTH 2* div } sub }
const short FIRE_Y            { CAMPFIRE_Y FIRE_WIDTH sub 6* add }
const byte  FIRE_FRAMES       { 4 }
const short FIRE_FRAME_STRIDE { 640* }

struct Campfire {
	byte fuel
	byte timer // Frames left untill consuming 1 fuel
	byte frame
	byte refueled-anim
}

var Campfire campfire

fun campfire-init ( -- ) {
	campfire-update-palette
	CAMPFIRE_MAX_FUEL campfire-set-fuel
	CAMPFIRE_TIMER_DELAY -> campfire.timer
}

fun campfire-update ( -- ) {
	campfire.timer 0 eq if {
		CAMPFIRE_TIMER_DELAY -> campfire.timer
		campfire.fuel 0 gth if { campfire.fuel 1 sub campfire-set-fuel }
	} else {
		campfire.timer 1 sub -> campfire.timer
	}

	// Update fire animation
	campfire.frame inc { FIRE_FRAMES FRAME_DELAY mul } mod -> campfire.frame
}

fun campfire-update-palette ( -- ) {
	// TODO: would be cool to refactor this to a macro if UXNSMAL had a macro system...
	campfire.fuel to-short LERP_COLOR_RESOLUTION mul CAMPFIRE_CRITICAL_FUEL div sth

	sth-rk 0x5* 0xf* lerp-color
	sth-rk 0x0* 0xa* lerp-color 0x40 shift or
	sth-rk 0x0* 0x0* lerp-color 0x80 shift or
	sth-r  0x0* 0xf* lerp-color 0xc0 shift or -> (c)
	(c) dup System.r output
	(c) dup System.g output
	(c)     System.b output
}

fun campfire-set-fuel ( byte -- ) {
	-> campfire.fuel
	campfire-update-palette
}
fun campfire-throw-flower ( -- ) {
	CAMPFIRE_FLOWER_FUEL campfire.fuel add -> (fuel)
	(fuel) CAMPFIRE_MAX_FUEL min -> (fuel)
	(fuel) campfire-set-fuel

	0 -> campfire.frame
	1 -> campfire.refueled-anim
	CAMPFIRE_TIMER_DELAY 3 mul -> campfire.timer
}

fun campfire-draw ( -- ) {
	CAMPFIRE_X Screen.x output
	CAMPFIRE_Y Screen.y output

	0b10000110       Screen.auto output
	&sprite-campfire Screen.addr output
	0b10000000 5 or  Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output-k
		output
}

fun campfire-fire-draw-below ( -- ) {
	{ dreloc.y DRELOC_HEIGHT add } { FIRE_Y FIRE_HEIGHT add } gth if {
		campfire-fire-draw
	}
}
fun campfire-fire-draw-above ( -- ) {
	{ dreloc.y DRELOC_HEIGHT add } { FIRE_Y FIRE_HEIGHT add } gth not if {
		campfire-fire-draw
	}
}

fun campfire-fire-draw ( -- ) {
	campfire.fuel 0 eq if { return }

	campfire.frame FRAME_DELAY div to-short -> (frame)
	(frame) FIRE_FRAME_STRIDE mul -> (frame)

	campfire.refueled-anim if {
		FIRE_FRAME_STRIDE 16* mul add -> (frame)
		campfire.frame { FIRE_FRAMES FRAME_DELAY mul } 1 sub eq if { 0 -> campfire.refueled-anim }
	} else {
		campfire.fuel sth
		/**/ sth-rk 10 lth if { FIRE_FRAME_STRIDE 12* mul add -> (frame) }
		elif sth-rk 20 lth    { FIRE_FRAME_STRIDE 8*  mul add -> (frame) }
		elif sth-rk 40 lth    { FIRE_FRAME_STRIDE 4*  mul add -> (frame) }
		pop-r
	}

	(frame) &sprite-fire add Screen.addr output

	0b01000110 Screen.auto output
	FIRE_X Screen.x output
	FIRE_Y Screen.y output
	0b11000101 Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output
}

// ==============================
// Flowers
// ==============================

const short FLOWER_WIDTH  { 16* }
const short FLOWER_HEIGHT { 38* }
const byte  FLOWER_BITS   { 0b11000101 }
const short FLOWERS_COUNT { 94* }
const short FLOWERS_GAP_Y { 5* }

struct Flower {
	short x
	byte  picked
}

rom var [94]Flower flowers

fun flowers-populate ( -- ) {
	0* -> (idx) while dup FLOWERS_COUNT lth {
		(idx) sth

		// Randomize X so that flowers do not overlap with the campfire
		0* -> (x) sth
		loop @exit {
			pop-r
			prng { SCREEN_WIDTH FLOWER_WIDTH sub } mod2 -> (x) sth

			sth-rk (x) CAMPFIRE_X     GRID_SIZE sub FLOWER_WIDTH sub lth
			sth-rk (x) CAMPFIRE_RIGHT GRID_SIZE add                  gth or
			swap-r
			sth-rk (idx) FLOWERS_GAP_Y mul sth
			sth-rk CAMPFIRE_Y FLOWER_HEIGHT sub GRID_SIZE sub lth or
			sth-r  CAMPFIRE_Y FLOWER_HEIGHT add GRID_SIZE add gth or
			swap-r
			if { jump @exit }
		}

		sth-r (x) sth-rk (idx) -> flowers[].x
		sth-r (idx) inc
	} pop
}

fun flowers-draw-below ( short:end-idx -- ) {
	sth
	0* while dup sth-rk lth {
		dup flower-draw
		inc
	} pop
	pop-r
}

fun flowers-draw-above ( short:start-idx -- ) {
	while dup FLOWERS_COUNT lth {
		dup flower-draw
		inc
	} pop
}

fun flower-draw ( short:idx -- ) {
	dup (idx) flowers[].picked if { pop return }

	(idx) dup 5* mod2 sth
	/**/ sth-rk 1* eq if { &sprite-flower-2 }
	elif sth-rk 2* eq    { &sprite-flower-3 }
	elif sth-rk 3* eq    { &sprite-flower-4 }
	elif sth-rk 4* eq    { &sprite-flower-5 }
	else                 { &sprite-flower-1 }
	pop-r

	Screen.addr output
	0b00010110 Screen.auto output

	{ dup (idx) FLOWERS_GAP_Y mul } Screen.y output
	{ dup (idx) flowers[].x } -> (x)

	// Calculate sine offset
	{ dup (x) 80* div } { rot (idx) 10* div } add
	{ elapsed 12* div } sub -> (sine-offset)

	// Draw rows of the flower sprite
	(x sine-offset)
	over over 60*  flower-draw-row
	over over 90*  flower-draw-row
	over over 120* flower-draw-row
	over over 150* flower-draw-row
	(sine-offset) pop

	// Draw the last (bottom) row of the sprite
	(x)         Screen.x output
	FLOWER_BITS Screen.sprite output
}

// Animate X position of a single flower sprite row using sine lookup table
fun flower-draw-row ( short:x short:sine-offset short:divide -- ) {
	swap

	// Calculate X shifting/tilt for the row
	(sine-offset) sin to-short swap (divide) div -> (tilt)

	(x tilt) add Screen.x output
	FLOWER_BITS  Screen.sprite output
}

// ==============================
// Snow flakes
// ==============================

const byte  FLAKE_BITS   { 0b01001111 }
const short FLAKES_COUNT { 60* }

// Flake
struct Flake {
	// X and Y are fixed point numbers with precision of 1
	short x
	short y
	short speed
}

rom var [60]Flake flakes

fun flakes-populate ( -- ) {
	0* while dup FLAKES_COUNT lth {
		sth
		{ prng SCREEN_WIDTH mod2 }  10* mul sth-rk -> flakes[].x
		{ prng SCREEN_HEIGHT mod2 } 10* mul sth-rk -> flakes[].y
		{ prng 10* mod2 }           10* add sth-rk -> flakes[].speed
		sth-r inc
	} pop
}

fun flakes-draw ( -- ) {
	0 Screen.auto output
	&sprite-flake Screen.addr output

	0* -> (idx) while dup FLAKES_COUNT lth {
		(idx) sth

		sth-rk flakes[].x -> (x)
		sth-rk flakes[].y -> (y)

		// Move flake vertically
		dup (y) { sth-rk flakes[].speed } add sth-rk -> flakes[].y

		// Move flake horizontally
		{ (y) 100* div } sth-rk (idx) add sin to-short 5* div -> (delta)
		(x delta) add sth-rk -> flakes[].x

		// Draw the flake
		// Devide X and Y by 10 because these are fixed point number with precision of 1
		{ sth-rk flakes[].x 10* div } -> (x) dup Screen.x output
		{ sth-rk flakes[].y 10* div } -> (y) dup Screen.y output
		FLAKE_BITS Screen.sprite output

		// Wrap flake from one screen edge to another
		(y) SCREEN_HEIGHT gth if { 0* sth-rk -> flakes[].y }
		(x) SCREEN_WIDTH  gth if { 0* sth-rk -> flakes[].x }

		sth-r (idx) inc
	} pop
}

// ==============================
// Utils
// ==============================

fun clamp ( short:value short:min short:max -- short ) {
	sth sth

	sth-r lth-k (value min _) if { pop-r nip return } else { pop }
	sth-r gth-k (value max _) if {       nip return } else { pop }
	(value)
}

fun min ( byte:a byte:b -- byte ) {
	over over (a b) gth
	if   { nip (b) -> (_) }
	else { pop (a) -> (_) }
}
fun min2 ( short:a short:b -- short ) {
	over over (a b) gth
	if   { nip (b) -> (_) }
	else { pop (a) -> (_) }
}

// Snap value to the grid
fun snap ( short -- short ) {
	GRID_SIZE div GRID_SIZE mul
}

fun not ( byte -- byte ) { 0 eq }
fun mod ( byte:num byte:divisor -- byte:remainder ) { div-k mul sub }
fun mod2 ( short:num short:divisor -- short:remainder ) { div-k mul sub }

fun to-short ( byte -- short ) { 0 swap as (short) }
fun to-byte ( short -- byte ) { as (byte:a byte:b) nip (b) }

// Pseudo-random functions ported from UXNTAL
// https://wiki.xxiivv.com/site/uxntal_software.html

var short prng-x
var short prng-y

fun prng-init ( -- ) {
	0 DateTime.second input as (short)
		0 DateTime.minute input as (short) 0x60 shift xor
		0 DateTime.hour   input as (short) 0xc0 shift xor -> prng-x
	0 DateTime.hour input as (short) 0x04 shift
		0 DateTime.day   input as (short) 0x10 shift xor
		0 DateTime.month input as (short) 0x60 shift xor
		DateTime.year input2 0xa0 shift xor -> prng-y
}
fun prng ( -- short ) {
	prng-x
		dup 0x50 shift xor
		dup 0x03 shift xor
	prng-y dup -> prng-x
		dup 0x01 shift xor xor
		&prng-y store-k pop
}


// Number of values inside `sine-lookup` table
const short SINE_LOOKUP_N { 30* }
data sine-lookup { include "assets/sine.bin" }

fun sin ( short -- byte ) {
	SINE_LOOKUP_N mod2 sine-lookup[]
}

const short LERP_COLOR_RESOLUTION { 100* }

fun lerp-color ( short:alpha short:from short:to -- short ) {
	over (to from) sub -> (diff)
	rot (from diff alpha)
	(alpha) LERP_COLOR_RESOLUTION min2 -> (alpha) // Clamp alpha so lerp doesn't overshoot
	(diff alpha) mul LERP_COLOR_RESOLUTION div -> (delta)
	(from delta) add
}

// ==============================
// Assets
// ==============================

data sprite-flake {
	0b01010100
	0b11010110
	0b00111000
	0b11111110
	0b00111000
	0b11010110
	0b01010100
	0b00000000
}

data sprite-dreloc   { include "assets/dreloc.chr" }
data sprite-campfire { include "assets/campfire.chr" }
data sprite-flower-1 { include "assets/flower-1.chr" }
data sprite-flower-2 { include "assets/flower-2.chr" }
data sprite-flower-3 { include "assets/flower-3.chr" }
data sprite-flower-4 { include "assets/flower-4.chr" }
data sprite-flower-5 { include "assets/flower-5.chr" }
data sprite-cursor   { include "assets/cursor.chr" }
data sprite-fire     { include "assets/fire.chr" }

const short NIMB_WIDTH  { 40* }
const short NIMB_HEIGHT { 40* }
data sprite-nimb { include "assets/nimb.icn" }

const short BLOOM_WIDTH  { 80* }
const short BLOOM_HEIGHT { 40* }
data sprite-bloom { include "assets/bloom.icn" }

const short GRASS_WIDTH        { 16* }
const short GRASS_HEIGHT       { 16* }
const short GRASS_FRAMES       { 5* }
const short GRASS_FRAME_STRIDE { 32* }
data sprite-grass { include "assets/grass.icn" }
