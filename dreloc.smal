// ==============================
// Devices
// ==============================

untyped enum byte System {
	r     { 0x08 }
	g     { 0x0a }
	b     { 0x0c }
	debug { 0x0e }
}

untyped enum byte Screen {
	vector { 0x20 }
	width  { 0x22 }
	height { 0x24 }
	auto   { 0x26 }
	x      { 0x28 }
	y      { 0x2a }
	addr   { 0x2c }
	pixel  { 0x2e }
	sprite { 0x2f }
}

untyped enum byte Mouse {
	vector { 0x90 }
	x      { 0x92 }
	y      { 0x94 }
	state  { 0x96 }
}

untyped enum byte DateTime {
	year   { 0xc0 }
	month  { 0xc2 }
	day    { 0xc3 }
	hour   { 0xc4 }
	minute { 0xc5 }
	second { 0xc6 }
	dotw   { 0xc7 }
	doty   { 0xc8 }
	isdst  { 0xca }
}

// ==============================
// Constants
// ==============================

enum byte Dir { down left up right }

const short SCREEN_WIDTH { 512* }
const short SCREEN_HEIGHT { 512* }

const short GRID_SIZE { 16* }

const short DRELOC_WIDTH             { 72* }
const short DRELOC_HEIGHT            { 96* }
const short DRELOC_WALK_SPEED        { 2* }
const byte  DRELOC_WALK_FRAMES_DELAY { 8 } // delay between anim frames in game frames
const byte  DRELOC_COLOR             { 5 }
const byte  DRELOC_WALK_FRAMES       { 4 }
const short DRELOC_FRAME_STRIDE      { 1728* } // data offset between frames in bytes

const byte  FLOWER_BITS   { 0b10000101 }
const short FLOWERS_COUNT { 94* }
const short FLOWERS_GAP_Y { 5* }
const short FLOWER_HEIGHT { 38* }

// ==============================
// Variables
// ==============================

struct Cursor {
	short prev-x
	short prev-y
}

struct Dreloc {
	short x
	short y
	short target-x
	short target-y
	byte  walk-frame
	byte  is-walking
	Dir   walk-dir
}

struct Flower {
	short x
}

// Number of frames elapsed from the start
var short elapsed

var Cursor cursor
var Dreloc dreloc

rom var [94]Flower flowers

// ==============================
// Vectors
// ==============================

fun on-reset ( -> ) {
	0xf0af* System.r output
	0xf0af* System.g output
	0xf0af* System.b output

	prng-init

	SCREEN_WIDTH  Screen.width output
	SCREEN_HEIGHT Screen.height output

	&on-screen Screen.vector output
	&on-mouse  Mouse.vector output

	flowers-populate
}

fun on-screen ( -> ) {
	// Clear the whole screen
	// TODO: may be i should come up with a better way to redraw game objects
	0* Screen.x output
	0* Screen.y output
	0b10000000 Screen.pixel output

	dreloc-update

	// Calculate index used for slicing the array of flowers
	{ dreloc.y DRELOC_HEIGHT add FLOWER_HEIGHT sub } FLOWERS_GAP_Y div -> (idx)

	(idx) dup flowers-draw-below

	dreloc-draw

	(idx) flowers-draw-above

	elapsed inc -> elapsed
}

fun on-mouse ( -> ) {
	&sprite-cursor Screen.addr output
	0 Screen.auto output

	// Clear previous cursor
	cursor.prev-x Screen.x output
	cursor.prev-y Screen.y output
	0b01000000 Screen.sprite output

	// Draw new cursor
	Mouse.x input2 { dup -> cursor.prev-x } Screen.x output
	Mouse.y input2 { dup -> cursor.prev-y } Screen.y output
	0b01000001 Screen.sprite output

	Mouse.state input if {
		{ Mouse.x input2 } { Mouse.y input2 } dreloc-set-target-pos
	}
}

// ==============================
// Dreloc
// ==============================

fun dreloc-set-target-pos ( short:x short:y -- ) {
	{
		{ (y) snap } DRELOC_HEIGHT SCREEN_HEIGHT clamp
		DRELOC_HEIGHT sub
	} -> dreloc.target-y

	{
		{ (x) snap } { DRELOC_WIDTH 2* div } { SCREEN_WIDTH DRELOC_WIDTH 2* div sub } clamp
		{ DRELOC_WIDTH 2* div } sub
	} -> dreloc.target-x
}

fun dreloc-move ( Dir:dir -- ) {
	dup (dir) Dir.right eq if {
		// Move right
		dreloc.x DRELOC_WALK_SPEED add -> dreloc.x
	} elif dup (dir) Dir.left eq {
		// Move left
		dreloc.x DRELOC_WALK_SPEED sub -> dreloc.x
	} elif dup (dir) Dir.down eq {
		// Move down
		dreloc.y DRELOC_WALK_SPEED add -> dreloc.y
	} elif dup (dir) Dir.up eq {
		// Move up
		dreloc.y DRELOC_WALK_SPEED sub -> dreloc.y
	}

	(dir) -> dreloc.walk-dir
	1     -> dreloc.is-walking
}

fun dreloc-update ( -- ) {
	0 -> dreloc.is-walking

	// Move to target
	dreloc.x dreloc.target-x eq if {
		// Move vertically
		dreloc.y dreloc.target-y neq if {
			/**/ dreloc.y dreloc.target-y lth if { Dir.down dreloc-move }
			elif dreloc.y dreloc.target-y gth    { Dir.up dreloc-move }
		}
	} else {
		// Move horizontally
		/**/ dreloc.x dreloc.target-x lth if { Dir.right dreloc-move }
		elif dreloc.x dreloc.target-x gth    { Dir.left dreloc-move }
	}

	dreloc.is-walking if {
		dreloc-update-walk-anim
	} else {
		DRELOC_WALK_FRAMES_DELAY 2 div -> dreloc.walk-frame
	}
}

fun dreloc-update-walk-anim ( -- ) {
	dreloc.walk-frame inc -> (frame)
	(frame) dup { DRELOC_WALK_FRAMES DRELOC_WALK_FRAMES_DELAY mul }
	eq if { (frame) pop 0 -> (frame) }

	(frame) -> dreloc.walk-frame
}

fun dreloc-draw ( -- ) {
	/**/ dreloc.walk-dir Dir.down  eq if { 0* }
	elif dreloc.walk-dir Dir.left  eq    { DRELOC_FRAME_STRIDE 3* mul }
	elif dreloc.walk-dir Dir.up    eq    { DRELOC_FRAME_STRIDE 6* mul }
	elif dreloc.walk-dir Dir.right eq    { DRELOC_FRAME_STRIDE 9* mul }
	else { 0* } -> (frame)

	dreloc.is-walking if {
		{ dreloc.walk-frame DRELOC_WALK_FRAMES_DELAY } div sth
		/**/ sth-kr 0 eq if { (frame) }
		elif sth-kr 1 eq    { (frame) DRELOC_FRAME_STRIDE add -> (frame) }
		elif sth-kr 2 eq    { (frame) }
		elif sth-kr 3 eq    { (frame) DRELOC_FRAME_STRIDE 2* mul add -> (frame) }
		pop-r
	}

	(frame) &sprite-dreloc add Screen.addr output

	dreloc.x Screen.x output
	dreloc.y Screen.y output

	0b10000110 Screen.auto output
	0b10000000 DRELOC_COLOR or Screen.sprite
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output-k
		output
}

// ==============================
// Flowers
// ==============================

fun flowers-populate ( -- ) {
	0* while dup FLOWERS_COUNT lth {
		sth
		{ prng SCREEN_WIDTH mod } sth-rk -> flowers[].x
		sth-r inc
	} pop
}

fun flowers-draw-below ( short:end-idx -- ) {
	sth
	0* while dup sth-rk lth {
		dup flower-draw
		inc
	} pop
	pop-r
}

fun flowers-draw-above ( short:start-idx -- ) {
	while dup FLOWERS_COUNT lth {
		dup flower-draw
		inc
	} pop
}

fun flower-draw ( short:idx -- ) {
	(idx) dup 3* mod sth
	/**/ sth-rk 1* eq if { &sprite-flower-2 }
	elif sth-rk 2* eq    { &sprite-flower-3 }
	else                 { &sprite-flower-1 }
	pop-r

	Screen.addr output
	0b00010110 Screen.auto output

	{ dup (idx) FLOWERS_GAP_Y mul } Screen.y output
	{ dup (idx) flowers[].x } -> (x)

	// Calculate sine offset
	{ dup (x) 80* div } { rot (idx) 10* div } add
	{ elapsed 12* div } sub -> (sine-offset)

	// Draw rows of the flower sprite
	(x sine-offset)
	over over 60*  flower-draw-row
	over over 90*  flower-draw-row
	over over 120* flower-draw-row
	over over 150* flower-draw-row
	(sine-offset) pop

	// Draw the last (bottom) row of the sprite
	(x)         Screen.x output
	FLOWER_BITS Screen.sprite output
}

// Animate X position of a single flower sprite row using sine lookup table
fun flower-draw-row ( short:x short:sine-offset short:divide -- ) {
	swap

	// Calculate X shifting/tilt for the row
	(sine-offset) sin to-short swap (divide) div -> (tilt)

	(x tilt) add Screen.x output
	FLOWER_BITS  Screen.sprite output
}

// ==============================
// Utils
// ==============================

fun clamp ( short:value short:min short:max -- short ) {
	sth sth

	sth-r lth-k (value min _) if { pop-r nip return } else { pop }
	sth-r gth-k (value max _) if {       nip return } else { pop }
	(value)
}

// Snap value to the grid
fun snap ( short -- short ) {
	GRID_SIZE div GRID_SIZE mul
}

fun not ( byte -- byte ) { 0 eq }
fun mod ( short:num short:divisor -- short:remainder ) { div-k mul sub }

fun to-short ( byte -- short ) { 0 swap as (short) }

// Pseudo-random functions ported from UXNTAL
// https://wiki.xxiivv.com/site/uxntal_software.html

var short prng-x
var short prng-y

fun prng-init ( -- ) {
	0 DateTime.second input as (short)
		0 DateTime.minute input as (short) 0x60 shift xor
		0 DateTime.hour   input as (short) 0xc0 shift xor -> prng-x
	0 DateTime.hour input as (short) 0x04 shift
		0 DateTime.day   input as (short) 0x10 shift xor
		0 DateTime.month input as (short) 0x60 shift xor
		DateTime.year input2 0xa0 shift xor -> prng-y
}
fun prng ( -- short ) {
	prng-x
		dup 0x50 shift xor
		dup 0x03 shift xor
	prng-y dup -> prng-x
		dup 0x01 shift xor xor
		&prng-y store-k pop
}


// Number of values inside `sine-lookup` table
const short SINE_LOOKUP_N { 30* }
data sine-lookup { include "assets/sine.bin" }

fun sin ( short -- byte ) {
	SINE_LOOKUP_N mod sine-lookup[]
}
// ==============================
// Assets
// ==============================

data sprite-cursor {
	0b11000000
	0b11100000
	0b11110000
	0b11111000
	0b11111100
	0b11000000
	0b00000000
	0b00000000
}

data sprite-dreloc   { include "assets/dreloc.chr" }
data sprite-flower-1 { include "assets/flower-1.chr" }
data sprite-flower-2 { include "assets/flower-2.chr" }
data sprite-flower-3 { include "assets/flower-3.chr" }
